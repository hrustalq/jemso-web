// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider      = "prisma-client-js"
    output        = "../generated/prisma"
    binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
}

// Blog Post model
model BlogPost {
    id          String   @id @default(cuid())
    title       String
    slug        String   @unique
    excerpt     String?
    content     String   // Legacy: Plain text/HTML content (kept for backward compatibility)
    blocks      Json?    // Legacy: Structured block content for page builder (deprecated, use htmlContent)
    htmlContent String?  // New: CKEditor HTML content (preferred for new content)
    coverImage  String?
    published   Boolean  @default(false)
    publishedAt DateTime?
    views       Int      @default(0)
    minTier     Int      @default(0) // 0 = free/everyone, higher value = higher tier required
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    authorId String
    author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

    categoryId String?
    category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

    tags     BlogPostTag[]
    comments Comment[]

    @@index([slug])
    @@index([authorId])
    @@index([categoryId])
    @@index([published, publishedAt])
    @@index([minTier])
}

// News model - Separated from BlogPost
model News {
    id          String   @id @default(cuid())
    title       String
    slug        String   @unique
    excerpt     String?
    content     String   // Plain text/HTML content
    htmlContent String?  // CKEditor HTML content
    coverImage  String?
    published   Boolean  @default(false)
    publishedAt DateTime?
    views       Int      @default(0)
    minTier     Int      @default(0) // 0 = free/everyone, higher value = higher tier required
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    authorId String
    author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

    categoryId String?
    category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

    tags     NewsTag[]
    
    // News doesn't necessarily need comments, but can be added if needed later

    @@index([slug])
    @@index([authorId])
    @@index([categoryId])
    @@index([published, publishedAt])
    @@index([minTier])
}

// Category model - Racing disciplines (drift, drag, ring, etc.)
model Category {
    id          String     @id @default(cuid())
    name        String     @unique
    slug        String     @unique
    description String?
    coverImage  String?    // Cover image for category page
    coverVideo  String?    // Cover video for category card (compressed, for hover preview)
    icon        String?    // Icon identifier for navigation
    color       String?    // Theme color for the category
    featured    Boolean    @default(false) // Show in featured sections
    order       Int        @default(0) // Display order in navigation
    showInNav   Boolean    @default(true) // Show in main navigation
    createdAt   DateTime   @default(now())
    updatedAt   DateTime   @updatedAt
    
    posts       BlogPost[]
    news        News[]
    events      Event[]
    userPreferences UserCategoryPreference[]

    @@index([slug])
    @@index([featured])
    @@index([order])
    @@index([showInNav])
}

// Tag model
model Tag {
    id        String        @id @default(cuid())
    name      String        @unique
    slug      String        @unique
    createdAt DateTime      @default(now())
    posts     BlogPostTag[]
    news      NewsTag[]

    @@index([slug])
}

// Junction table for many-to-many relationship between BlogPost and Tag
model BlogPostTag {
    id         String   @id @default(cuid())
    postId     String
    tagId      String
    assignedAt DateTime @default(now())

    post BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)
    tag  Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@unique([postId, tagId])
    @@index([postId])
    @@index([tagId])
}

// Junction table for many-to-many relationship between News and Tag
model NewsTag {
    id         String   @id @default(cuid())
    newsId     String
    tagId      String
    assignedAt DateTime @default(now())

    news News @relation(fields: [newsId], references: [id], onDelete: Cascade)
    tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@unique([newsId, tagId])
    @@index([newsId])
    @@index([tagId])
}

// Comment model
model Comment {
    id        String   @id @default(cuid())
    content   String
    approved  Boolean  @default(false)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    postId String
    post   BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)

    authorId String
    author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

    parentId String?
    parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
    replies  Comment[] @relation("CommentReplies")

    @@index([postId])
    @@index([authorId])
    @@index([parentId])
    @@index([approved, createdAt])
}

// Newsletter Subscription model
model NewsletterSubscriber {
    id            String    @id @default(cuid())
    email         String    @unique
    name          String?
    active        Boolean   @default(true)
    confirmedAt   DateTime?
    unsubscribedAt DateTime?
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    
    categoryPreferences NewsletterCategoryPreference[]

    @@index([email])
    @@index([active, confirmedAt])
}

// Newsletter category preferences - Filter news by category
model NewsletterCategoryPreference {
    id           String   @id @default(cuid())
    subscriberId String
    categoryId   String
    createdAt    DateTime @default(now())
    
    subscriber NewsletterSubscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
    
    @@unique([subscriberId, categoryId])
    @@index([subscriberId])
    @@index([categoryId])
}

// ========================================
// Event Management System
// ========================================

// Event model - Similar to BlogPost but for events
model Event {
    id              String   @id @default(cuid())
    title           String
    slug            String   @unique
    excerpt         String?
    content         String?  // Legacy: Plain text/HTML content
    blocks          Json?    // Legacy: Structured block content for page builder (deprecated, use htmlContent)
    htmlContent     String?  // New: CKEditor HTML content (preferred for new content)
    coverImage      String?
    published       Boolean  @default(false)
    publishedAt     DateTime?
    views           Int      @default(0)
    minTier         Int      @default(0) // 0 = free/everyone, higher value = higher tier required
    
    // Event-specific fields
    startDate       DateTime
    endDate         DateTime
    location        String?
    locationUrl     String?  // For online events or maps
    maxParticipants Int?     // null = unlimited
    price           Decimal  @default(0)
    currency        String   @default("USD")
    
    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt

    authorId String
    author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

    categoryId String?
    category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

    registrations EventRegistration[]

    @@index([slug])
    @@index([authorId])
    @@index([categoryId])
    @@index([published, startDate])
    @@index([startDate, endDate])
    @@index([minTier])
}

// Event Registration model - Tracks who registered for events
model EventRegistration {
    id              String    @id @default(cuid())
    status          String    @default("pending") // pending, confirmed, canceled, attended
    paymentStatus   String    @default("pending") // pending, paid, refunded
    paymentMethod   String?
    paidAmount      Decimal?
    registeredAt    DateTime  @default(now())
    confirmedAt     DateTime?
    canceledAt      DateTime?
    cancelReason    String?
    attendedAt      DateTime?
    notes           String?   // Admin notes
    createdAt       DateTime  @default(now())
    updatedAt       DateTime  @updatedAt

    eventId String
    event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([eventId, userId]) // One registration per user per event
    @@index([eventId])
    @@index([userId])
    @@index([status])
    @@index([paymentStatus])
}

// ========================================
// RBAC (Role-Based Access Control) Models
// ========================================

// Role model - Dynamic roles
model Role {
    id          String   @id @default(cuid())
    name        String   @unique
    slug        String   @unique
    description String?
    isSystem    Boolean  @default(false) // System roles cannot be deleted
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    userRoles       UserRole[]
    rolePermissions RolePermission[]

    @@index([slug])
}

// Permission model - Dynamic permissions
model Permission {
    id          String   @id @default(cuid())
    name        String   @unique
    slug        String   @unique
    description String?
    resource    String   // e.g., "blog_post", "user", "subscription"
    action      String   // e.g., "create", "read", "update", "delete"
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    rolePermissions RolePermission[]

    @@unique([resource, action])
    @@index([slug])
    @@index([resource])
}

// Junction table for Role-Permission many-to-many
model RolePermission {
    id           String   @id @default(cuid())
    roleId       String
    permissionId String
    assignedAt   DateTime @default(now())

    role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
    permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

    @@unique([roleId, permissionId])
    @@index([roleId])
    @@index([permissionId])
}

// Junction table for User-Role many-to-many
model UserRole {
    id         String   @id @default(cuid())
    userId     String
    roleId     String
    assignedAt DateTime @default(now())
    expiresAt  DateTime? // Optional: role can expire

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
    role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

    @@unique([userId, roleId])
    @@index([userId])
    @@index([roleId])
    @@index([expiresAt])
}

// ========================================
// Subscription System Models
// ========================================

// Subscription Plan model - Dynamic plans
model SubscriptionPlan {
    id               String   @id @default(cuid())
    name             String   @unique
    slug             String   @unique
    description      String?
    price            Decimal  @default(0)
    currency         String   @default("USD")
    billingInterval  String   @default("month") // month, year, lifetime
    trialDays        Int      @default(0)
    isActive         Boolean  @default(true)
    maxUsers         Int?     // null = unlimited
    maxStorage       Int?     // in MB, null = unlimited
    order            Int      @default(0) // Display order
    createdAt        DateTime @default(now())
    updatedAt        DateTime @updatedAt

    features         PlanFeature[]
    subscriptions    UserSubscription[]
    checkoutSessions CheckoutSession[] @relation("CheckoutPlan")

    @@index([slug])
    @@index([isActive])
}

// Feature model - Dynamic features
model Feature {
    id          String   @id @default(cuid())
    name        String   @unique
    slug        String   @unique
    description String?
    featureType String   @default("boolean") // boolean, numeric, text
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    planFeatures PlanFeature[]

    @@index([slug])
}

// Junction table for Plan-Feature with values
model PlanFeature {
    id        String   @id @default(cuid())
    planId    String
    featureId String
    value     String? // For numeric/text features, null for boolean (implies true)
    createdAt DateTime @default(now())

    plan    SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)
    feature Feature          @relation(fields: [featureId], references: [id], onDelete: Cascade)

    @@unique([planId, featureId])
    @@index([planId])
    @@index([featureId])
}

// User Subscription model
model UserSubscription {
    id                String    @id @default(cuid())
    userId            String
    planId            String
    status            String    @default("active") // active, canceled, expired, trial
    startDate         DateTime  @default(now())
    endDate           DateTime?
    trialEndsAt       DateTime?
    canceledAt        DateTime?
    cancelReason      String?
    paymentMethod     String?
    lastPaymentDate   DateTime?
    nextPaymentDate   DateTime?
    autoRenew         Boolean   @default(true)
    promoCodeId       String?   // Applied promo code
    discountAmount    Decimal?  // Discount amount applied
    createdAt         DateTime  @default(now())
    updatedAt         DateTime  @updatedAt

    user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
    plan      SubscriptionPlan  @relation(fields: [planId], references: [id])
    promoCode PromoCode?        @relation(fields: [promoCodeId], references: [id], onDelete: SetNull)

    @@index([userId])
    @@index([planId])
    @@index([status])
    @@index([endDate])
    @@index([promoCodeId])
}

// Promo Code model - Discount codes for subscriptions
model PromoCode {
    id              String    @id @default(cuid())
    code            String    @unique
    description     String?
    discountType    String    @default("percentage") // percentage, fixed
    discountValue   Decimal   // Percentage (0-100) or fixed amount
    currency        String    @default("USD") // For fixed discounts
    maxUses         Int?      // null = unlimited
    usedCount       Int       @default(0)
    minPurchase     Decimal?  // Minimum purchase amount required
    maxDiscount     Decimal?  // Maximum discount amount (for percentage)
    validFrom       DateTime  @default(now())
    validUntil      DateTime?
    isActive        Boolean   @default(true)
    planIds         String[]  // Empty = applies to all plans
    createdAt       DateTime  @default(now())
    updatedAt       DateTime  @updatedAt

    subscriptions    UserSubscription[]
    checkoutSessions CheckoutSession[]

    @@index([code])
    @@index([isActive])
    @@index([validUntil])
}

// Checkout Session model - Temporary storage for checkout data
model CheckoutSession {
    id              String    @id @default(cuid())
    userId          String
    planId          String
    promoCodeId     String?
    billingName     String?
    billingEmail    String?
    billingAddress  String?
    billingCity     String?
    billingCountry  String?
    billingPostal   String?
    originalPrice   Decimal
    discountAmount  Decimal   @default(0)
    finalPrice      Decimal
    currency        String    @default("USD")
    status          String    @default("pending") // pending, completed, expired
    expiresAt       DateTime
    completedAt     DateTime?
    createdAt       DateTime  @default(now())
    updatedAt       DateTime  @updatedAt

    user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
    plan      SubscriptionPlan  @relation("CheckoutPlan", fields: [planId], references: [id])
    promoCode PromoCode?        @relation(fields: [promoCodeId], references: [id], onDelete: SetNull)

    @@index([userId])
    @@index([planId])
    @@index([status])
    @@index([expiresAt])
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    image         String?
    password      String?   // Hashed password for credentials provider
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    
    accounts            Account[]
    sessions            Session[]
    blogPosts           BlogPost[]
    news                News[]
    comments            Comment[]
    userRoles           UserRole[]
    subscriptions       UserSubscription[]
    passwordResetTokens PasswordResetToken[]
    events              Event[]
    eventRegistrations  EventRegistration[]
    categoryPreferences UserCategoryPreference[]
    checkoutSessions    CheckoutSession[]
    
    @@index([email])
}

// User category preferences - User's favorite categories for personalized content
model UserCategoryPreference {
    id         String   @id @default(cuid())
    userId     String
    categoryId String
    notifyNews Boolean  @default(true) // Send notifications for news in this category
    notifyEvents Boolean @default(true) // Send notifications for events in this category
    createdAt  DateTime @default(now())
    
    user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
    
    @@unique([userId, categoryId])
    @@index([userId])
    @@index([categoryId])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// Password Reset Token model
model PasswordResetToken {
    id        String   @id @default(cuid())
    token     String   @unique
    userId    String
    expires   DateTime
    used      Boolean  @default(false)
    createdAt DateTime @default(now())

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([token])
    @@index([userId])
    @@index([expires])
}
